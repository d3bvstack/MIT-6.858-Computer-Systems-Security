Threat Models

Security: achieving a goal when an adversary is present.

- An adversary is trying to hinder you from achieving your goal.
- A secure system is one that allows the user to achieve the intended goal regardless of what the adversary is trying to do to the user or system.

1. **Policy**: statement about what I want my system to do
   - confidentiality
   - integrity
   - availability
   - etc.
2. **Threat model**: assumptions about the adversary.
3. **Mechanism**: software/hardware/system that makes sure the policy is followed as long as the adversary fits the threat model.

End result: as long as our threat model was correct, we will hopefully satisfy our policy via the mechanism working properly.

This is an iterative process: on each iteration, find the weakest link, then change the model a bit and try to design a new system that makes things better. Every system has weaknesses and a breaking point.

## Examples of how security goes wrong

**Policy that goes wrong**: account recovery questions. These questions change the policy that only users who know the password to an account can access it; now it can be accessed either by knowing the password or the response to one of these recovery questions, weakening the system's security.

- [Google, Amazon, Apple example diagram]
- Be conservative on policy setting; avoid depending on external systems.

**Threat models that go wrong**: human factors. We normally make assumptions about what users will do in a system, like picking strong passwords or not clicking random links, etc. Do not have a threat model that makes strong assumptions about what humans will do.

Sometimes threat model assumptions change, like encryption key sizes over time.

- [SSL/TLS certificate authorities example and diagram]
- DARPA secure OS example.

**Mechanisms that go wrong**: mechanisms are often the most complicated part of security models; there is no end to the ways in which mechanisms can fail.

- Example: Apple cloud infrastructure – they do not enforce the same mechanisms across all interfaces (e.g., unlimited guesses on some interfaces).
  - [Diagram of iCloud interfaces and mechanisms example]
- Example: Citibank workflow – login/password, then redirection to an account page with an ID; if the ID is changed, an attacker could get access to someone else's account.
- Example: Android Bitcoin app – random function where the library had a bug with seed initialization.

In security, every detail can have dramatic consequences. Push on all the edges to find how robust the system is.

- SSL example with null characters
- Buffer overflows example (understand the logic but still do not fully get the code) (modern protections: permissions associated with some memory regions to protect against these buffer overflow attacks)
