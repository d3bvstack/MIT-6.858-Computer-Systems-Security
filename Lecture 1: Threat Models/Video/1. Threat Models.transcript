[00:00:00] The following content is provided under a Creative Commons license. Your support will help MIT OpenCourseWare
[00:00:06] continue to offer high quality educational resources for free. To make a donation or to view additional materials
[00:00:12] from hundreds of MIT courses, visit MIT OpenCourseWare at ocw.mit.edu
[00:00:26] PROFESSOR: In this class, this semester, the other co-lecturer is going to be James Mickens, who is a visiting professor from Microsoft
[00:00:32] Research. He'll lecture on some other topics like web security later on.
[00:00:37] But we'll decide later what's going on exactly, in terms of the lecture split up. We also have four TAs this year, Stephen, Webb, [INAUDIBLE],
[00:00:46] and James. And hopefully you'll meet them in office hours over the year
[00:00:52] if you need help. So the plan for this class is to understand
[00:00:57] how to build secure systems, why computer systems sometimes are insecure and how we can make them better,
[00:01:04] and what goes wrong. And in order to do this, there's not really a great textbook about this topic.
[00:01:09] So instead, what we're going to do is, each lecture other than this one is going to be focused around some research, typically a paper,
[00:01:16] that we'll assign on the website and you guys should read ahead of time. And there are some question that you
[00:01:22] should answer in the submission system about the paper. And submit your own question by 10:00 PM before the lecture
[00:01:28] day. And then when you come to lecture, we'll actually discuss the paper, figure out, what is the system? What problem does it solve?
[00:01:34] When does it work? When does it not work? Are these ideas any good in other cases? Et cetera.
[00:01:39] And hopefully, through these case studies, we'll get some appreciation of how do we actually build
[00:01:45] systems that are secure. And we have some preliminary schedule up on the website. If there's other topics you guys are particularly interested in,
[00:01:52] or if there's particular papers you're excited about, just send us email and we'll see if we can fit them in or do something.
[00:01:57] We're pretty flexible. So if there's anything that you'd like to hear more about, just let us know.
[00:02:03] And in a similar vein, if you ever have a question or if there's some mistake, just interrupt and ask
[00:02:11] us what's going on in lecture, anytime. Security is, in many ways, all about the details
[00:02:18] and getting everything right. And I will inevitably make mistakes. So if something doesn't seem right,
[00:02:23] there's a good chance it's not. And you should just interrupt and ask. And we'll figure out what's going on and what's the right way to do things.
[00:02:30] And I guess in terms of the class organization, the other large part of the class, in addition to lectures, is going
[00:02:36] to be a series of lab assignments. The first one is already posted on the website. And these lab assignments will help
[00:02:42] you go through understanding the different range of security problems and how do you prevent them in a simple web server.
[00:02:51] So in lab one, which is out right now, you'll actually take a web server that we give you and find ways to exploit buffer overflow
[00:02:58] vulnerabilities in it and take control of this website by just sending it carefully-crafted requests
[00:03:04] and packets. And in other labs, you'll look at ways to defend the web server, to find bugs in the code,
[00:03:10] to write worms that run in the user's browser, and other kinds of interesting security problems.
[00:03:18] One thing that surprises many students is that every lab uses a different language.
[00:03:24] So lab one is all about C and Assembly. Lab two involves a lot of Python coding. Lab three will be something else.
[00:03:30] Lab five will be JavaScript. And so on. This is sort of inevitable. And I sort of apologize ahead of time
[00:03:36] that you're going to have to learn all these languages if you haven't seen them already. In some ways it's useful, because the real world
[00:03:42] is like this. All the systems are complicated and composed of different parts. And in the long run, it'll be useful for you,
[00:03:48] for your moral character or something like that, to learn this stuff. But it will take some preparation,
[00:03:53] especially if you haven't seen these languages before. It might be helpful to start early. In particular, lab one is going to rely
[00:04:00] on a lot of subtle details of C and Assembly code that we don't really teach in other classes
[00:04:06] here in as much detail. So it's probably a good idea to start early. And we'll try to get the TAs to hold office hours next week
[00:04:12] where we'll do some sort of a tutorial session where we can help you get started with understanding what
[00:04:18] a binary program looks like, how to disassemble it, how to figure out what's on the stack, and so on.
[00:04:25] All right. And I guess the one other thing, we're actually videotaping lectures this year. So you might be able to watch these online.
[00:04:33] We'll post them as soon as we get them ourselves from the video people. And the last bit of administrivia
[00:04:39] is you should, if you have questions online, we're using Piazza, so I'm sure you've
[00:04:44] used this in other classes. All right. So before we dive into security, I need to tell you one thing.
[00:04:51] There is a sort of rules that MIT has for accessing MIT's network when you're, especially, doing security
[00:04:58] research or playing with security problems, you should be aware that not everything you can technically
[00:05:03] do is legal. And there's many things that you will learn in this class that
[00:05:08] are technically possible. We'll understand how systems can be broken or compromised.
[00:05:13] Doesn't mean you should go out and do this everywhere. And there's this link in the lecture notes
[00:05:19] we'll post that has some rules that are good guidelines. But in general, if you're in doubt, ask one of the lecturers or a TA as to what you should do.
[00:05:28] And hopefully it's not too puzzling, what's going on.
[00:05:34] All right. So any questions about all this administrivia before we dive in? Feel free to ask questions.
[00:05:42] OK. So what is security? So we'll start with some basic stuff today.
[00:05:47] And we'll look at just some general examples of why security is hard and what it means to try
[00:05:53] to build a secure system. Because there's not really a paper, this will not have sort of deep intellectual content, maybe,
[00:05:59] but it'll give you some background and context for how to think about secure systems. So security, in general, is all about
[00:06:06] achieving some goal when there is an adversary present.
[00:06:13] So think of it as there's some bad guy out there that wants to make sure you don't succeed.
[00:06:18] They want to steal your files. They want to delete your entire hard drive contents. They want to make sure nothing works
[00:06:24] and your phone doesn't connect, all these things, right? And a secure system is one that can actually
[00:06:30] do something, regardless of what the bad guy is trying to do to you. So it's kind of cool that we can actually potentially build
[00:06:35] systems that are resilient to a whole range of bad guys, adversaries, attackers,
[00:06:41] whatever you want to call them. And we can still build computer systems that allow us to get our work done.
[00:06:48] And the general way to think about security
[00:06:53] is sort of break it up into three parts. One part is roughly the policy that you
[00:07:00] want your system to enforce. This is roughly the goal that you want to achieve. Like well, maybe, only I should be
[00:07:05] able to read the grades file for 6.858. Or maybe the TAs as well, and all the co-lecturers,
[00:07:11] et cetera. But there is some statement about what I want my system to be able to do. And then, if you want sort of think
[00:07:18] about what kinds of policies you might write, typical ones have to do with either confidentiality of data,
[00:07:26] so the grades file is only accessible to the 6.858 course staff.
[00:07:32] Another example of a security policy has something to do with integrity. For example, only the course staff can also modify the grades file.
[00:07:38] Or only the course staff can upload the final grades to the registrar's office. That'll be great. Then you can also think about things like availability.
[00:07:47] So for example, a website should be available, even if the bad guys try to take it down and mount
[00:07:54] some sort of a DOS-- Denial of Service-- attack on it. So this is all well and good.
[00:07:59] So these are the policies that we might actually care about from a system. But because it's security, there's a bad guy involved.
[00:08:05] We need to understand, what are we thinking the bad guy is going to do? And this is typically what we call a threat model.
[00:08:13] And this is basically just a set of assumptions about the bad guy or adversary.
[00:08:23] And it's important to have some sort of assumptions about the bad guy because, if the bad guy is omnipresent
[00:08:29] and is everywhere at once and you can do anything they want, it's going to be hard to achieve some semblance of security.
[00:08:36] So for example, you probably want to assume the bad guy doesn't exactly know your password, or they don't actually have physical access to your phone
[00:08:43] and your keys and your laptop. Otherwise, it's going to be hard to make some sort of progress in this game.
[00:08:50] And turns out that while this is actually quite tricky to come up with, but I guess one general rule is it's
[00:08:56] much better err on the side of caution and being conservative in picking your threat model,
[00:09:01] because bad guy might always surprise you in terms of what they might be able to do in practice.
[00:09:07] And finally, in order to achieve security, in order to achieve our goal under the set of assumptions,
[00:09:12] we're going to look at some mechanism. And this is the, basically, software or hardware
[00:09:21] or whatever part of system design, implementation, et cetera, that's going to try to make sure our policy is followed
[00:09:30] as long as the bad guy follows the threat model. So the end result is that, as long
[00:09:36] as our threat model was correct, hopefully we'll satisfy our policy. And it has to be the case that the mechanism doesn't screw up.
[00:09:44] Make sense? Fairly high level story about how to think about this kind of stuff.
[00:09:50] So why is this so hard, right? It seems like a simple plan. You write down these three things, and you're off and running.
[00:09:57] But in practice, as you, I'm sure, have seen in the world, computer systems are almost always compromised
[00:10:04] in some way or another. And break ins are pretty commonplace. And the big reason why security tends
[00:10:12] to be a difficult problem is because what we have here is sort of, this will be familiar to those of you
[00:10:17] took 6.033, this is a negative goal, meaning that we have to make sure our security policy is
[00:10:23] followed regardless of what the attacker can do. So just by contrast, if you want to build a file system,
[00:10:30] and you want to make sure that my TAs can access the grades
[00:10:36] file, that's pretty easy. I just ask them, hey, can you guys test and see? Can you access the grades file?
[00:10:41] And if they all can access it, done. The system works. But if I want to say that no one other than the TAs
[00:10:48] can access the grades file, this is a much harder problem to solve, because now I have to figure out what could all these non TA people in the world to try
[00:10:56] to get my grades file, right? They could try to just open it and read it.
[00:11:01] Maybe my file system will disallow it. But they might try all kinds of other attacks, like guessing the password for the TAs
[00:11:07] or stealing the TAs laptops or breaking into the room or who knows, right? This is all stuff that we have to really put
[00:11:14] into our threat model. Probably for this class, I'm not that concerned about the grades file to worry about these guys' laptops being
[00:11:21] stolen from their dorm room. Although maybe I should be. I don't know. It's hard to tell, right? And as a result, this security game
[00:11:27] is often not so clear cut as to what the right set of assumptions to make is.
[00:11:32] And it's only after the fact that you often realize, well should have thought of that.
[00:11:39] All right. And sort of, as a result, this is very much an iterative process. And the thing you end up realizing at every iteration
[00:11:46] is, well, here's the weakest link into my system. Maybe I got the threat model wrong. Maybe my mechanism had some bugs in it because it's a software
[00:11:53] and it's going to be large systems. They'll have lots of bugs. And you sort of fix them up.
[00:11:58] You change your threat model a bit. And you iterate and try to design a new system, and hopefully, make things better.
[00:12:06] So one possible interpretation of this class-- well, one danger-- is that you come away thinking, man, everything
[00:12:14] is just broken. Nothing works. We should just give up and stop using computers. And this is one possible interpretation.
[00:12:21] But it's probably not quite the right one. The reason this is going to come up or you're going to think this way
[00:12:26] is because, throughout this class, we're going to look at all these different systems, and we're going to sort of push them to the edge. We're going to see, OK, well, what if we do this?
[00:12:33] Is it going to break? What if we do that? Is it going to break then? And inevitably, every system is going to have some sort of a breaking point.
[00:12:38] And we'll figure out, oh hey. This system, we can break it in if we push this way. And this system doesn't work under these set of assumptions.
[00:12:46] And it's inevitable that every system will have a breaking point. But that doesn't mean that every system is worthless.
[00:12:51] It just means you have to know when to use every system design. And it's sort of useful to do this pushing exercise
[00:12:57] to find the weaknesses so that you know when certain ideas work, when certain ideas are not
[00:13:03] applicable. And in reality, this is a little more fuzzy boundary, right?
[00:13:09] The more secure you make your system, the less likely you'll have some embarrassing story on the front page of New
[00:13:14] York Times saying, your start up company leaked a million people's social security numbers.
[00:13:21] And then you pay less money to recover from that disaster.
[00:13:26] And I guess one sort of actually positive note on security is that, in many ways, security enables cool things that you
[00:13:33] couldn't do before, because security, especially mechanisms, that allow us to protect
[00:13:40] against certain classes of attacks, are pretty powerful. As one example, the browser used to be fairly boring in terms
[00:13:46] of what you could do with it. You could just view web pages, maybe run some JavaScript code in it. But now there's all these cool mechanisms
[00:13:52] we'll learn about in a couple of weeks that allow you to run arbitrary x86 native code in the web
[00:13:57] browser and make sure it doesn't do anything funny to your machine. And it can send-- and there's a technique or system
[00:14:04] called Native Client from Google that actually allows us to do this securely. And before, in order to run some native game on your machine,
[00:14:11] you'd have download and install it, click on lot's of dialogue boxes, say yes, I allow this. But now, you can just run it in a browser,
[00:14:17] no clicking required. It just runs. And the reason it's so easy and powerful is that our security mechanism can sandbox this program
[00:14:25] and not have to assume anything about the user choosing the right game and not some malicious game to play
[00:14:31] in their computer, or some other program to run. So in many ways, good security mechanisms are going to enable constructing cool new systems that weren't
[00:14:40] possible to construct before. All right. Make sense? Any questions about this story?
[00:14:50] All right. So I guess in the rest of the lecture, I want to go through a bunch of different examples of how
[00:14:58] security goes wrong. So, so far, we've seen how you can think of it. But inevitably, it's useful to see examples
[00:15:05] of what not to do so that you can have a better mindset when you're approaching security problems.
[00:15:12] And in this sort of breakdown of a security system, pretty much every one of these three things goes wrong.
[00:15:18] In practice, people get the policy wrong, people get the threat model wrong, and people get the mechanism wrong. And let's, I guess, start with policies and examples
[00:15:27] of how you can screw up a system's policy. Maybe the cleanest or sort of simplest example of this
[00:15:35] are account recovery questions.
[00:15:41] So typically, when you sign into a website, you provide a password.
[00:15:47] But what happens if you lose your password? Some sites will send you email if you
[00:15:52] lose your password with a link to reset your password. So it's easy enough, if you have another email address. But what if this is your email provider?
[00:15:59] So at least, several years ago, Yahoo hosted email, webmail, for anyone on the internet.
[00:16:06] And when you forgot your Yahoo password, they couldn't really send you email because you couldn't get it. So instead, they had you register
[00:16:13] a couple of questions with them that hopefully only you know. And if you forget your password, you can click on a link
[00:16:18] and say, well, here's the answers to my questions. Let me have my password again. And what turns out to be the case is-- well,
[00:16:26] some people failed to realize is that this changes your policy, because before, the policy of the system
[00:16:32] is people that can log in are the people that know the password. And when you introduce these recovery questions,
[00:16:38] the policy becomes, well, you can log in if you know either the password or those security questions.
[00:16:44] So it strictly weakens the security of your system. And many people have actually taken advantage of this. One sort of well known example is, I think a couple years ago,
[00:16:53] Sarah Palin had an email account at Yahoo. And her recovery questions were things like, well,
[00:16:59] where'd you go to school? What was your friend's name? What's your birthday? Et cetera.
[00:17:04] These were all things written on her Wikipedia page. And as a result, someone can quite easily, and someone did, actually, get into her Yahoo email account
[00:17:12] just by looking up on Wikipedia what her high school was and what her birthday was. So you really have to think carefully
[00:17:18] about the implications of different security policies you're making here.
[00:17:24] Perhaps a more intricate and, maybe, interesting example, is what happens when you have multiple systems that start
[00:17:32] interacting with one another. So there's this nice story about a guy called Mat Honan.
[00:17:39] Maybe you read this story a year or two ago. He's a editor at this wired.com magazine.
[00:17:45] And had a bit of a problem. Someone basically got into his Gmail account and did lots of bad things.
[00:17:52] But how did they do it, right? So it's kind of interesting. So all parties in this story seem
[00:17:57] to be doing reasonable things. But we'll see how they add up to something unfortunate. So we have Gmail. And Gmail lets you reset your password
[00:18:06] if you forget, as do pretty much every other system. And the way you do a reset at Gmail
[00:18:13] is you send them a reset request. And what they say is, well, you weren't
[00:18:19] going to do this recovery questions, at least not for this guy. What they do is they send you a recovery link to a backup email
[00:18:24] address, or some other email address that you have. And helpful, they actually print the email address for you. So for this guy's account, someone
[00:18:31] went and asked Gmail to reset the password. And they said, well, yeah. Sure. We just sent the recovery link to this email,
[00:18:37] foo@me.com, which was some Apple email service.
[00:18:42] OK, but the bad guy doesn't have access to me.com, either. But they want to get this password reset link to get access to Gmail.
[00:18:48] Well, the way things worked was that, in Apple's case, this me.com site,
[00:18:55] allowed you to actually reset your password if you know your billing address and the last four digits of your credit
[00:19:03] card number. So it's still not clear how you're going to get this guy's-- well, home address, maybe you could look it up
[00:19:10] somewhere. This guy was a well known person at the time. But where do you get the last four digits of his credit card number?
[00:19:16] Well, not clear, but let's keep going further. So you need to send these things to me.com to get access
[00:19:23] to his email account there. Well, it turns out this guy had an account at Amazon, which is another party in this story.
[00:19:31] Amazon really wants you to buy things. And as a result, they actually have a fairly elaborate account
[00:19:38] management system. And in particular, because they really want you to buy stuff, they don't require you to sign in
[00:19:44] in order to purchase some item with a credit card. So I can actually go on Amazon, or at least at the time,
[00:19:50] I was able to go on Amazon and say, well, I'm this user. And I want to buy this pack of toothbrushes.
[00:19:57] And if I wanted to use the saved credit card number in the guy's account, I shouldn't be able to do this.
[00:20:02] But if I just was providing a new credit card, what Amazon would do is, they can actually add a new credit
[00:20:08] card to some guy's account.
[00:20:13] So that seems not too bad, right? I'm basically ordering toothbrushes through one of your Amazon accounts.
[00:20:18] But it's not your credit card anyway. It's just my credit card number being used. So it's not clear how things go wrong yet.
[00:20:24] But Amazon had another interface. All these are complicated systems. And Amazon had an interface for password reset.
[00:20:31] And in order to reset a password in Amazon, what you had to provide is just one of the user's credit card
[00:20:38] numbers. So I can order stuff and add a credit card number to your account. And then I can say, hey, I want to reset my password.
[00:20:45] This is one of my credit card numbers. And this, in fact, worked. So this is where the bad guy got a hold of this guy's, Mat's,
[00:20:53] Amazon account. But OK. How do you fish out the credit card number for resetting Apple's site?
[00:20:59] Well, Amazon was actually very careful. Even if you break into someone's Amazon account, it will not print you the saved credit card
[00:21:05] numbers from that person. But it will show the last four digits. Just so you know which credit card you're talking about.
[00:21:11] So you can list all the credit cards, other than the one you added. You can then go and break into me.com.
[00:21:16] You can click on this link and get access to the guy's Gmail account. This is all very subtle stuff.
[00:21:22] And in isolation, each system seems to be doing somewhat sensible things. But it's actually quite hard to reason
[00:21:28] about these vulnerabilities and weaknesses unless you have this whole picture explained to you
[00:21:34] and you've sort of put all the pieces together. So this is actually fairly tricky stuff.
[00:21:41] And unfortunately, well, much like for every one of these three categories, the answer for how to avoid this
[00:21:47] is often think hard and be careful. I guess the one general plan is, be conservative in terms
[00:21:54] of what you set your policy to be, to maybe not depend on things other sites might reveal.
[00:22:01] So well, I'm not sure if any really great advice would have prevented this problem.
[00:22:06] But now you know. And now you'll make other mistakes. There's many other examples of policies
[00:22:13] going wrong and allowing a system to be compromised. That's interesting enough.
[00:22:19] But let's look at how people might screw up threat models. So let me turn off this blue square.
[00:22:28] OK. So what are examples of threat models that go wrong?
[00:22:36] Well, probably a big one in practice is human factors.
[00:22:42] So we often make assumptions about what people will do in a system, like they
[00:22:49] will pick a good, strong password, or they will not click on random websites that they get through email and enter their password there.
[00:22:56] So these are-- well, as you probably suspect, and in practice, happens to be the case, these are not good assumptions in all cases.
[00:23:03] And people pick bad passwords. And people will click on random links. And people will enter their password
[00:23:10] on sites that are actually not the right site at all. And they will not be paying a lot of attention.
[00:23:16] So you probably don't want to have threat models that make very strong assumptions about what humans will do because inevitably, something
[00:23:23] will go wrong. Make sense? Any questions?
[00:23:29] All right. Another sort of good thing to watch out in threat models is that they sometimes change over time.
[00:23:35] Or whether something is a good assumption or not changes over time. One example of this is actually at MIT in the mid '90s-- mid
[00:23:45] '80s, actually-- Project Athena developed this system called Kerberos. And we'll read about this in a couple of weeks in this class.
[00:23:52] And at the time, they were sort of figuring out, well, Kerberos is going to be based on cryptography. So we need to pick some size keys
[00:23:59] to make sure they're not going to be guessed by arbitrary people. And they said, OK. Well you know, 56-bit keys, at the time,
[00:24:06] for this cypher called DES, seemed like a plausible size. Maybe not great, but certainly not entirely unreasonable.
[00:24:13] And this was in the mid '80s. But then you know, this system got popular and got used a lot. MIT still uses it.
[00:24:19] And they never really went back to seriously revisit this assumption. And then, a couple years ago, a group of 6.858 students
[00:24:27] figured out that actually, yeah, you can just break this, right? It's easy enough to enumerate all the 256 keys these days.
[00:24:34] Computers are so fast, you can just do it. And as a result, they were able to, with the help of some hardware from a particular web
[00:24:42] service-- we'll have some links the lecture notes-- they were able to get, basically, anyone's Kerberos account key in roughly
[00:24:50] a day. And so this assumption was good in the mid 1980s. No longer a good assumption today.
[00:24:57] So you really have to make sure your assumptions sort of keep up with the times.
[00:25:02] Maybe a more timely example is, if your adversary-- or if you're worried about government attacks,
[00:25:08] you might realize that you shouldn't trust hardware even these days, right? There was all these revelations about what
[00:25:14] the NSA is capable of doing. And they have hardware back doors that they can insert into computers.
[00:25:20] And maybe up until a couple years ago, well, who knows? I guess we didn't know about this stuff. So maybe it was a reasonable assumption
[00:25:27] to assume your laptop is not going to be compromised physically, the hardware itself. But now you know.
[00:25:32] Actually, if you're worried about the government being after you, you probably have a much harder problem to deal with because your laptop might
[00:25:39] be compromised physically, regardless of what you install in it. So we really have to be careful with your threat model
[00:25:44] and really sort of balance it against who you think is out to get you. I think it's going to be a very expensive proposition if you're
[00:25:50] going to try to protect yourself from the NSA, really. On the other hand, if you're just protecting yourself from random other students that are,
[00:25:57] I don't know, snooping around in your Athena home directory or whatnot, maybe you don't have to worry about this stuff as much.
[00:26:03] So it's really a balancing game and picking the right threat model.
[00:26:08] Another example of a bad threat model shows up in the way
[00:26:15] secure websites these days check certificates of a website that you're connecting to. So in this SSL protocol or TLS, when you connect to a website
[00:26:23] and it says HTTPS-- we'll talk much more about this in later lectures-- but what happens
[00:26:28] is that the site you're connecting to presents you a certificate signed by one of the certificate authorities
[00:26:34] out there that attests that, yep, this key belongs to Amazon.com.
[00:26:39] And architecturally, the sort of mistake or the bad threat model that these guys assumed
[00:26:46] is that all these CAs are going to be trustworthy. They will never make a mistake. And in fact, the way system works
[00:26:52] is that there's hundreds of these CAs out there. The Indian postal authority, I think, has a CA.
[00:26:58] The Chinese government has a CA. Lots of entities are certificate authorities in this design.
[00:27:04] And any of them can make a certificate for any host name or a domain name. And as a result, what happens if you're a bad guy,
[00:27:11] if you want to compromise Gmail or if you want to impersonate Gmail's website, you just have to compromise one of these certificate authorities.
[00:27:18] And it turns out the weakest link is probably some poorly run authority somewhere in some, you know, not particularly up to date country.
[00:27:26] Who knows, right? And as a result, it's probably a bad assumption to build a system-- or it's a bad idea
[00:27:33] to build a system around the assumption that you'll manage to keep all 300 certificate
[00:27:38] authorities spread out around the globe perfectly secure. But yet, that's the assumption underpinning
[00:27:44] the security mechanism of today's SSL protocol used by web browsers.
[00:27:51] And there's sort of many other, I guess, examples that are things you might not have thought of.
[00:27:58] Another sort of amusing example from the 1980s was DARPA.
[00:28:04] This defense agency, at the time, really wanted to build secure operating systems.
[00:28:10] And they actually went so far as to get a bunch of universities and researchers to build secure OS prototypes.
[00:28:17] And then they actually got a red team, like a team of bad guys pretending to be the attackers,
[00:28:23] and told them, well, go break into these secure operating systems any way you can. We actually want to know, is it secure?
[00:28:29] And it's kind of amusing, some of the surprising ways they compromised the systems. One was that there was this OS research
[00:28:36] team that seemed to have a perfectly secure OS, but it got compromised. And the way it happened is that the server in which the source
[00:28:42] code of the operating system was stored was some development machine in someone's office that wasn't secured at all. But that had all the source code.
[00:28:48] So the bad guys broke into that server. It was not protected very well. Changed the source code of the operating system to introduce a back door.
[00:28:54] And then, when the researchers built their operating systems, well, it had this back door. And the bad guys were able to break in.
[00:29:00] So you really have to think about all the possible sort of assumptions you're making about
[00:29:05] where your software is coming from, about how the bad guy can get in, in order to make sure your system is really secure.
[00:29:14] And there's many other examples in lecture notes, if you want. So I'm using anecdotes.
[00:29:19] You can page through those. Probably the most pervasive problem that shows up,
[00:29:28] of course, is in mechanisms, though. And in part, it's because mechanisms are the most complicated part of the story.
[00:29:35] It's the entirety of all the software and hardware and all that sort of system components
[00:29:41] that make up what is trying to enforce your security policy. And there's no end of ways in which mechanisms can fail.
[00:29:49] And, partly as a result, much of this class
[00:29:55] will focus pretty heavily on mechanisms and how do you make mechanisms that are secure,
[00:30:00] that provide correct enforcement of security policies. And we'll talk about threat models and policies as well.
[00:30:06] But turns out it's much easier to make clean,
[00:30:12] sort of crisp statements about mechanisms and ways they work and don't work, as opposed to policies and threat
[00:30:18] models which, really, you have to figure out how to fit them into a particular context where you're using a system.
[00:30:24] So let's look at some examples of, I guess, mechanism bugs.
[00:30:30] One that you might have heard in the last couple of days was a problem in the security mechanism in Apple's cloud
[00:30:38] infrastructure called iCloud. Well actually, any one of you that has an iPhone
[00:30:45] might be using this iCloud service. They basically provide storage for files and let you find your iPhone if you lose it, and probably
[00:30:53] lots of other useful features. And I think it's some relative of this me.com service
[00:30:58] that was implicated in this scheme a couple years back. And the problem that someone discovered
[00:31:04] in this iCloud service is that they didn't enforce the same sort of mechanism at all interfaces.
[00:31:11] OK, so what does iCloud look like? Well, it basically provides lots of services for the same sort
[00:31:18] of set of accounts. So maybe you have your file storage on iCloud. Maybe you have your photo sharing.
[00:31:26] Maybe you have other interfaces. And one of the interfaces into iCloud-- these are all sort of at different APIs that they provide-- was this feature to find my iPhone,
[00:31:35] I think. And all these interfaces want to make sure that you are the right user, you're authenticated correctly.
[00:31:42] And unfortunately, the developers all this iCloud system, you know it's a giant piece of software.
[00:31:48] I'm sure lots of developers worked on this. But on this particular interface, the find my iPhone interface, when
[00:31:55] you tried to log in with a username and password, they didn't keep track of how many times you tried to log in.
[00:32:02] And the reason is important is that, as I mentioned earlier, humans are not that great at picking good passwords.
[00:32:07] So actually building a system that authenticates users with passwords is pretty tricky. We'll actually read a whole paper about this later on.
[00:32:14] But one good strategy is, there's probably a million passwords out there that will account
[00:32:22] for 50% percent of accounts. So if you can guess, make a million attempts at someone's account, then there's
[00:32:28] a good chance you'll get their password because people actually pick predictable passwords. And one way to try to defeat this
[00:32:34] is to make sure that your system doesn't allow an arbitrary number of attempts to log in to an account.
[00:32:39] Maybe after three or 10 tries, you should say, well, you've had enough tries.
[00:32:44] Time out. You can try again in 10 minutes or in an hour. And this way you really slow down the attacker.
[00:32:50] So they can only make a handful of guesses a day, instead of millions of guesses.
[00:32:56] And as a result, even if you have not the greatest of passwords, it's going to be pretty hard for someone to guess it.
[00:33:01] What would happen is that iCloud had this password guessing
[00:33:06] prevention or, basically, back off, on some interfaces, like if you tried to log in through other interfaces
[00:33:12] and you failed 10 times, it would say, well, sorry. You have to wait until you try again. But on this find my iPhone interface,
[00:33:18] they forget this check. That's probably, you know, some guy just forgot to call this function on this API. But the result is that, for the same set of accounts,
[00:33:26] a bad guy would be able to now guess your password through this interface at millions of attempts per day
[00:33:32] easily, because this is just limited up to how fast they can send packets to this iCloud thing. And they can probably guess your password
[00:33:39] with pretty good accuracy, or with pretty good success rate, after making many guesses.
[00:33:46] And this led to some unfortunate break ins. And people's confidential data got stolen from this iCloud service.
[00:33:54] So this is sort of an example of you had the right policy. Only the user and the right password
[00:34:01] would get you access to the files. You even had the right threat model that, well, the bad guy might be able to guess the password.
[00:34:06] So we'll have to break limit the number of guess attempts. But he just screwed up, like the mechanism had a bug in it.
[00:34:12] He just forgot to enforce this right policy and mechanism at some interface. And this shows up again and again in systems,
[00:34:19] where just made a mistake and it has pretty drastic effects on the security of the overall system.
[00:34:27] This make sense? Any questions so far?
[00:34:33] All right. OK. So another example-- this is sort of an example of you
[00:34:39] forget to check for password guessing attempts. There's many other things you can forget.
[00:34:44] You could forget to check for access control altogether. So one example is, Citibank had a website-- actually, still
[00:34:53] has a website that allows you to look at your credit card account information.
[00:34:58] So if you have a credit card with Citibank, you go to this website, it tells you, yeah, you have this credit card. Here's all the charges, all this great stuff.
[00:35:04] And the workflow a couple of years ago was that you go to some site, you provide a log in username and password,
[00:35:12] and you get redirected to another URL, which is something like, I don't know, I'm guessing,
[00:35:18] but basically like citi.com/account?id= you know,
[00:35:23] whatever, one two three four. And it turns out that some guy figured out, well,
[00:35:29] if you change this number, you just get someone else's account. And it's not clear quite how to think of this.
[00:35:37] One possibility is that these guys were just thinking right, but they, again, forgot to check a function in this account
[00:35:43] page that, not only do I have a valid ID number, but it's also the ID number of the guy that's
[00:35:48] currently logged in. It's an important check to me. But it's easy to forget.
[00:35:53] Another thing is, maybe these guys were thinking, no, no one could hit URLs. Maybe they had a bad threat model, right? Maybe they're thinking, the URL--
[00:36:00] if I don't print this URL, no one can click on it. It's like a bad threat model. So maybe that's-- well, it's hard to tell exactly what went
[00:36:07] wrong. But anyway, these mistakes do happen. And they show up a lot.
[00:36:12] So easy to have small, seemingly, bugs in your mechanism lead to pretty unfortunate consequences.
[00:36:24] Another example that's not so much in missing checks is a problem that showed up on Android
[00:36:30] phones a couple of months ago. Maybe I'll use this board over here.
[00:36:38] So the problem was related to Bitcoin, which is this-- well, I'm sure you've heard-- this electronic currency
[00:36:44] system that's pretty popular these days. And the way that Bitcoin works, at a very high level,
[00:36:54] is that your balance of Bitcoins is associated with a private key.
[00:37:00] And if you have someone's private key you can, of course, spend their Bitcoins. So the security of Bitcoin relies quite heavily
[00:37:10] on no one else knowing your private key. It's kind of like a password, except it's even more
[00:37:15] important, because people can probably make lots of guesses at your private key. And there's no real server that's checking your key.
[00:37:21] It's just cryptography. So any machine can try to make lots of guesses at your private key. And if they guess it, then they can transfer your Bitcoins
[00:37:28] to someone else. And as a result, it's critically important that you generate good, random keys
[00:37:34] that no one else can guess. And there are people using Bitcoin on Android.
[00:37:41] And the Android applications for Bitcoin were getting random values for these keys using this Java API called SecureRandom(),
[00:37:51] which sounds great, but as people figured out, well, OK. So what it is, right, it doesn't really get real random numbers.
[00:37:59] Inside of it, there's this construction called Pseudorandom Number Generator,
[00:38:04] or PRNG that, given a particular seed value, like you get maybe a couple of hundred
[00:38:09] bits of randomness and you shove it into this PRNG, you can keep asking it for more randomness and sort of stretch
[00:38:15] these random bits into as many random bits as you want. So you see them initially, and then you
[00:38:22] can generate as many random bits as you want. And for various cryptographic reasons I won't go into here, it actually works.
[00:38:27] If you give it a couple of hundred really good random bits initially, it's going to be very hard for anyone to predict what the pseudorandom values it's generating are.
[00:38:37] But the problem is that this Java library had a small bug in it. In some set of circumstances, it forgot
[00:38:44] to initialize the PRNG with a seed, so it was just all zeros, which means that everyone could just
[00:38:50] figure out what your random numbers were. If they start with zeros, they'll produce the same random numbers as you, which means they'll produce the same private key as you.
[00:38:57] So they can just generate the same private key and transfer your Bitcoins. So this is, again, a small or not small bug,
[00:39:05] depending on, I guess, who is asking. But nonetheless, right? Another example of small programming mistakes
[00:39:12] leading to pretty catastrophic results. Lot's of people got their Bitcoin balances stolen because of this weakness.
[00:39:19] Of course, the fix is pretty simple at some level. You change the Java implementation of SecureRandom() to always seed this PRNG with random input
[00:39:28] bits. And then, hopefully, you're in good shape. But still, that's yet another example of mechanism failure.
[00:39:36] Yeah? AUDIENCE: Just to be clear, is this a different attack from the DSA signature randomness?
[00:39:42] PROFESSOR: Well yeah. So the actual problem is a little bit more complicated, as you're hinting at. The problem is, even if you didn't generate
[00:39:48] your key on the Android device in the first place, the particular signature scheme used by Bitcoin
[00:39:56] assumes that every time you generate a new signature with that key, you use a fresh, what's
[00:40:01] called a nonce, for generating that signature. And if you ever generate two signatures with the same nonce,
[00:40:07] then someone can figure out what your key is. The story is pretty similar. But the details are a little different. So yeah, even if you actually generated your key somewhere
[00:40:14] else and your key was great, it's just that every time you generate a signature, you would--
[00:40:19] and you generated two signatures with exactly the same nonce, or random value, someone could apply some clever math
[00:40:26] to your signatures and sort of extract your public key out of it. Or private key, more importantly.
[00:40:34] All right. Other questions about these problems, examples, et cetera?
[00:40:40] All right. So I guess, one thing I wanted to point out is that actually,
[00:40:46] well, as you're starting to appreciate, is that in computer security, almost every detail has
[00:40:52] a chance of really mattering. If you screw up almost something seemingly inconsequential,
[00:40:58] like forgetting to check something, or this, or forgetting to initialize the random seed, it can have pretty dramatic consequences
[00:41:04] for the overall system. And you really have to be very clear about, what is the specification of your system?
[00:41:11] What is it doing? Exactly what are all the corner cases? And a good way to sort of think of breaking a system
[00:41:17] or, conversely, figure out if your system is secure, is to really push all the edge cases, like what happens if my input is just large enough?
[00:41:23] Or what is the biggest or the smallest input? What is the sort of strangest set
[00:41:28] of inputs I could provide to my program and push it in all these corner cases?
[00:41:34] One example of this ambiguity, sort of a good example to keep in mind, is how SSL certificates, again,
[00:41:44] encode names into the certificate itself. So this is a different problem than the problem
[00:41:51] about the certificate authorities being trusted. So these SSL certificates are just sequences of bytes
[00:41:57] that a web server sends to you. And inside of this SSL certificate is the name of the server you're connecting to,
[00:42:04] so something like Amazon.com. You know, you can't just put down those bytes. You have to encode it somehow and specify, well,
[00:42:09] it's Amazon.com. And that's the end of the string. So in SSL certificates, they use a particular encoding scheme
[00:42:18] that writes down Amazon.com by first writing down
[00:42:24] the number of bytes in the string. So you first write down, OK. Well, I'm going to have a 10 byte string called Amazon.com.
[00:42:32] That's actually 10 bytes. Great. OK.
[00:42:37] So this is like-- in the SSL certificate, somewhere in there, there is this byte 10 followed by 10 bytes saying
[00:42:44] what the host name is. And there's other stuff afterwards, right, and before. And when a browser takes it, well, the browser
[00:42:50] is written in C. And the way C represents strings is by null terminating them.
[00:42:56] So in C, a string doesn't have a length count. Instead, it has all the bytes. And the end of the string is just the byte zero.
[00:43:03] And in C, you write it with a backslash zero character. So this is in memory in your browser.
[00:43:08] Somewhere in memory there's this string of 11 bytes, now, with an extra zero at the end.
[00:43:15] And when a browser interprets this string, it just keeps going until it sees an end of string marker, which is a zero byte.
[00:43:22] OK. So, what could go wrong? Any guesses?
[00:43:28] Yeah? AUDIENCE: You have a zero in the middle [INAUDIBLE]? PROFESSOR: Yes. This is great. All right. So, this is actually a bit of a discontinuity
[00:43:35] in terms of how this guy represents strings and this guy. So suppose that I own the domain foo.com.
[00:43:41] So I can get certificates for anything dot foo dot com. So what I could do is ask for a certificate for the name
[00:43:50] amazon.com0x.foo.com.
[00:43:57] That's a perfectly valid string. It has a bunch of bytes. I guess it's 10, 11 12 13, 14, 15, 16,
[00:44:03] there's another four, 20, right? So this is 20 byte name with these 20 bytes.
[00:44:10] So it used to be that if you go to a certificate authority, in many cases, you could say, hey, I own foo.com.
[00:44:15] Give me a certificate for this thing. And they'd be perfectly willing to do it because it's a subdomain of foo.com.
[00:44:20] It's all yours. But then, when a browser takes this string and loads it in memory, well, what it does is the same thing
[00:44:27] it did here. It copies the string. amazon.com0x.foo.com.
[00:44:37] It'll dutifully add the terminating zero at the end. But then, when the rest of the browser software
[00:44:43] goes and tries to interpret the string at this memory location, it'll keep going up until it gets to zero and say, OK well,
[00:44:50] that's the end of the string. So this is Amazon.com. That's it. So this sort of disconnect between how C software
[00:45:00] and how SSL certificates represent names led to some unfortunate security problems.
[00:45:05] This was actually discovered a number of years ago now by this guy, Moxie Marlinspike.
[00:45:11] But it's a fairly clever observation. And these kinds of encoding bugs are actually also
[00:45:17] pretty common in lots of software because, unless you're very diligent about exactly how you
[00:45:24] encode things, there might be different ways of encoding. And whenever there's disagreement, there's a chance the bad guy can take advantage of this.
[00:45:30] One system thinks that's a fine name. Another thinks that's not, something else. So these are good places to sort of push a system
[00:45:36] to see how it might break. That make sense?
[00:45:42] All right. So maybe the last example of mechanism failure
[00:45:47] I'm going to talk about today is a reasonably popular one. It's this problem or buffer overflows.
[00:45:52] So some of you have seen this in, or at least at some level,
[00:45:59] in 6.033, if you did the undergrad course. But for those of you that have forgotten or haven't taken
[00:46:05] oh three three, we'll sort of go over buffer overflows in more detail. And this will be, actually, quite critical for you guys,
[00:46:10] because lab one is all about buffer overflows. And you're going to be exploiting these vulnerabilities in a somewhat real web server.
[00:46:19] So let's figure out, what is the setting? What are we talking about here? So the setting we're going to be considering
[00:46:25] is a system which has, let's say, a web server. So what we have is, we have some computer out there
[00:46:34] that has a web server on it. And the web server is a program that
[00:46:41] is going to accept connections from the outside world, take requests-- which are basically just packets--
[00:46:47] and somehow process them, and do some checking, probably. If it's an illegal URL or if they're
[00:46:54] trying to access a file they are not authorized to access, the web server is going to return an error. But otherwise, it's going to access some files,
[00:47:00] maybe on disk, and send them back out in some sort of a reply.
[00:47:06] So this is a hugely common picture, almost any system you look at. What's the policy?
[00:47:13] Or what's the threat model?
[00:47:18] So this is a bit of a problem in many real world systems, namely that it's actually pretty hard
[00:47:23] to pin down what is the exact policy or threat model that we're talking about. And this sort of imprecision or ambiguity about policies,
[00:47:31] threat models, et cetera, is what sometimes leads to security problems. Not in this particular case, but we'll see.
[00:47:37] But maybe just to give you a sense of how to think of a typical web server in the context of this policy,
[00:47:44] threat model kind of stuff, is that well, probably the policy is, the web server should do what the programmer intended
[00:47:50] it to do. It's a little vague. But that's probably what's going on because anything more specific, as well, the web server should
[00:47:55] do exactly what the code does, is going to be a bit of an [INAUDIBLE] And if your code has a bug, well, your policy says, well, that's
[00:48:01] exactly what I should do. I should follow the bug. So it's a little hard to state a policy precisely,
[00:48:07] but in this case, let's go with some intuitive version of, well, the web server should do what the programmer wanted it to do.
[00:48:13] And the threat model is probably, the attacker doesn't have access to this machine, can't log in to it remotely, doesn't have physical access
[00:48:20] to it, but can send any packet they want. So they're not restricted to certain kinds of packets.
[00:48:26] Anything you can shape and sort of deliver to this web server, that's fair game. Seems like a reasonable threat model, in practice,
[00:48:32] to have in mind. And I guess the goal is that this web server shouldn't
[00:48:39] allow arbitrary stuff to go wrong here. I guess that sort of goes along with what the programmer intended.
[00:48:45] The programmer probably didn't intend any request to be able to access anything on the server. And yet, it turns out if you make certain kinds of mistakes
[00:48:51] in writing the web server software, which is basically the mechanism here, right? The web server software is the thing that takes a request
[00:48:57] and looks at it and makes sure that it's not going to do something bad, sends a response back if everything's OK. The web server in this mechanism.
[00:49:03] It's enforcing your policy. And as a result, if the web server software is buggy,
[00:49:08] then you're in trouble. And one sort of common problem, if you're writing software in C which, you know,
[00:49:14] many things are still written in C and probably will continue to be written in C for a while, you can mismanage your memory allocations.
[00:49:21] And as we saw in this SSL certificate naming example, even sort of a single byte can really
[00:49:27] make a huge difference, in terms of what goes on. And I guess for this example, we'll
[00:49:32] look at a small piece of code that's not quite a real web server. In the lab, you'll have this whole picture to play with.
[00:49:38] But for lecture, I just want to give you a simplified example so we can talk about what's sort of at the core of what's going wrong.
[00:49:47] And, in particular, if this system wakes up, I will show you sort of a very small C function.
[00:49:56] And we can sort of see what goes wrong if you provide different inputs to that piece of code.
[00:50:04] All right. So the C function that I have in mind is this guy.
[00:50:09] Somewhere here.
[00:50:15] Oh, yeah. It's coming on.
[00:50:21] All right. So here's the sort of program I'm talking about,
[00:50:27] or I want to use as an example here. So this program is just going to read a request.
[00:50:32] And you can sort of imagine it's going to read a request from the network. But for the purposes of this example,
[00:50:38] it's just going to read a request from whatever I'm typing in on the keyboard. And it's going to store it in a buffer here.
[00:50:45] And then it's going to parse it is an integer and return the integer. And the program will then print whatever integer I get back.
[00:50:52] It's like far from a web server. But we'll at least see some basics of how buffer overflows work and what goes wrong.
[00:51:00] So let's see actually what happens if we run this program. So I can compile it here. And actually, you can sort of see
[00:51:07] the-- it's already telling me what I'm screwing up, right? The get function is dangerous and should not be used.
[00:51:13] And we'll see in a second why the compiler is so intent on telling me this. And it actually is true.
[00:51:20] But for now, suppose we're a happy go lucky developer that is willing to ignore this warning.
[00:51:26] So OK. I run this redirect function, I provide some input, and it works.
[00:51:33] Let's see if I provide large inputs. If I type in some large number, well, at least it gives me some large number.
[00:51:38] It basically maxes out to two to the 31 and prints that and doesn't go any higher.
[00:51:44] So that's maybe not disastrous, right? Whatever. You provided this ridiculously large number.
[00:51:49] You got something didn't quite work. It's not quite a problem yet. But if we provide some really large input,
[00:51:55] we might get some other problem, right? So suppose I provide in a lot of by 12
[00:52:00] I just provided things that are not numbers. It prints zero. That's not so bad.
[00:52:06] But suppose I'm going to paste in a huge number of As. OK, so now the program crashes.
[00:52:13] Maybe not too surprising. So if it was the case that if I send a bad request to the web server, it just doesn't get back to me or doesn't send a reply,
[00:52:20] that would be fine. But we'll sort of look inside and see what happens, and try to figure out how we can actually
[00:52:25] take advantage of this crash to maybe do something much more interesting, or, well, much more along with what a hacker might
[00:52:35] be interested in doing. So to do this, we're going to run this program under a debugger. You'll get super familiar with this in lab one.
[00:52:43] But for now, what we're going to do is set a breakpoint in that redirect function.
[00:52:49] And we're going to sort of run along and see what happens. So when I run the program, it's going to start executing in the main function.
[00:52:56] And pretty quickly, it calls redirect. And the debugger is now stopped at the beginning of redirect.
[00:53:01] And we can actually see what's going on here by, for example,
[00:53:06] we can ask it to print the current CPU registers. We're going to look at really low level stuff here, as opposed to at the level of C source code.
[00:53:13] We're going to look at the actual instructions that my machine is executing because that's what really is going on. The C is actually maybe hiding some things from us.
[00:53:20] So you can actually print all the registers. So on x86, as you might remember.
[00:53:25] Well, on [INAUDIBLE] architecture, there's a stack pointer. So let me start maybe drawing this diagram on the board
[00:53:32] so we can try to reconstruct what's happening. So what's going on is that my program, not surprisingly,
[00:53:39] has a stack. On x86, the stack grows down. So it sort of is this stack like this.
[00:53:46] And we can keep pushing stuff onto it. So right now, the stack pointer points
[00:53:51] at this particular memory location FFD010.
[00:53:58] So some value. So you can try to figure out, how did it get there? One way to do it is to disassemble the code
[00:54:05] of this redirect function.
[00:54:12] Is this going to work better? Really? Convenience variable must have integer value.
[00:54:18] Man. What is going on with my debugger?
[00:54:28] All right. Well, we can disassemble the function by name. So this is what the function is doing.
[00:54:33] So first off, it starts by manipulating something with this EBP register. That's not super interesting.
[00:54:38] But the first thing it does after that is subtract a certain value from the stack pointer.
[00:54:43] This is, basically, it's making space for all those variables, like the buffer and the integer, i, we saw in the C source code.
[00:54:50] So we're actually, now, four instructions into the function, here. So that stack pointer value that we
[00:54:57] saw before is actually already in the middle, so to say, of the stack.
[00:55:02] And currently, there's stuff above it that is going to be the buffer, that integer
[00:55:09] value, and actually, also the return address into the main function goes on the stack, as well. So somewhere here, we'll have the return address.
[00:55:17] And we actually try to figure out, where are things on the stack? So we can print the address of that buffer variable.
[00:55:26] So the buffer variable is at address D02C. We can also print the value of that integer, i.
[00:55:35] That guy is at D0AC. So the i is way up on the stack.
[00:55:40] But the buffer is a bit lower. So what's going on is that we have our buffer here
[00:55:47] on the stack, and then followed above by i and maybe
[00:55:52] some other stuff, and then finally, the return address into the main function that called redirect. And the buffer is-- this is going,
[00:56:00] the stack is growing down. So these are higher addresses.
[00:56:07] So what this means is that the buffer-- we actually have to decide, where is the zeroth element of the buffer,
[00:56:13] and where is the 128th element of this buffer? So where does the zeroth element of the buffer go?
[00:56:20] Yeah? Should be at the bottom, right, because yeah, higher elements just keep going up.
[00:56:25] So buff of zero is down here. It just keeps going on. And buff of 127 is going to be up there.
[00:56:31] And then we'll have i and other stuff. OK. Well, let's see what happens now if we
[00:56:36] provide that input that seemed to be crashing it before. So I guess one thing we can actually do before this is to see whether we can actually
[00:56:43] find this return address. Where it actually happens to live is at the EBP pointer.
[00:56:48] This is just a convenient thing in the x86 calling convention, that the EBP pointer, or register, actually
[00:56:59] happens to point to something on the stack which is going to be called the saved EBP.
[00:57:06] It's a separate location, sort of after all the variables but before the return address. And this is the thing that's being
[00:57:11] saved by those first couple of instructions at the top. And you actually sort of examine it. In GDB you can say, examine x, some value, so the EBP pointer
[00:57:23] value. So that's the location of the stack, D0B8. Indeed, it's actually above even the i variable.
[00:57:30] So it's great. And it has some other value that happens to be the EBP before this function was called.
[00:57:36] But then, sort of one more memory location up is going to be the return address. So if we print EBP plus four, there's something else there,
[00:57:44] this 0x08048E5F. And let's actually see where that's pointing.
[00:57:51] So this is something you're going to do a lot in the lab. So you can take this address. And you can try to disassemble it.
[00:57:59] So what is this guy? Where did we end up? So GDB actually helpfully figures out which function
[00:58:05] contains that address. So 5F. This is the guy that our return address is pointing to.
[00:58:11] And as you can see, this is the instruction right after the call to redirect. So when we return from redirect, this
[00:58:17] is exactly where we're going to jump and continue execution. This is, hopefully, fairly straightforward stuff from double oh four, some standard OS class.
[00:58:25] OK. So where are we now? Just to recap, we can try to disassemble our instruction
[00:58:33] pointer. So we're at the beginning of redirect right now. And we can run for a bit, and maybe run that getS() function.
[00:58:43] So OK, we run next. What this does is it runs getS() and it's waiting for getS()
[00:58:48] to return. We can provide our bad input to getS() and try to get it to crash again and see what's going on, really, there, right?
[00:58:54] So we can paste a bunch of As again. OK. So we got out of getS() and things are actually still OK,
[00:59:00] right? The program is still running. But we can try to figure out, what is in memory right now
[00:59:05] and why are things going to go wrong? Actually, what do you guys think? What happened, right?
[00:59:11] So I printed out a bunch of As. What did getS() do to the memory?
[00:59:16] Yeah, yeah. So it just keeps writing As here, right? All we actually passed to getS() was a single pointer, the start of this address, right?
[00:59:23] So this is the argument to getS(), is a pointer to this memory location on the stack.
[00:59:28] So it just kept writing As. And it doesn't actually know what the length is, so it just keeps going, right? It's going to override As all the way up the stack,
[00:59:36] past the return address, probably, and into whatever was up the stack above us. So we can check whether that's the case.
[00:59:42] So we can actually print the buffer. And in fact, it tells us, yeah, we
[00:59:48] have 180 As there, even though the buffer should be 128 elements large.
[00:59:55] So this is not so great. And we can actually, again, examine what's going on in that EBP pointer.
[01:00:03] Dollar sign, EBP. So in fact, yeah. It's all 0x41, which is the ASCII encoding of the letter A.
[01:00:12] And in fact, the return address is probably going to be the same way, right? If we print the return address, it's also all As.
[01:00:19] That's not so great. In fact, what's going to happen if we return now is the program will jump to that address, 41414141.
[01:00:25] And there's nothing there. And it'll crash. That's the segmentation fault you're getting. So let's just step up to it and see what happens.
[01:00:33] So let's run next. So we keep stepping through the program. And we can see where we are.
[01:00:40] OK. We're getting close to the end of the function. So we can step over two more instructions.
[01:00:46] nexti. And now we can disassemble again.
[01:00:51] OK. We're now just at the return instruction from this function. And we can actually figure out. So as you can see, at the end of the function,
[01:00:59] it runs this leave x86 instruction, which basically restores the stack back to where it was.
[01:01:05] So it sort of pushes the stack pointer all the way back to the return address using the same EBP. That's what it's basically for.
[01:01:11] And now, the stack is pointing at the return address that we're going to use. And in fact, it's all A's.
[01:01:18] And if we run one more instruction, the CPU is going to jump to that exact memory address and start executing code there and crash,
[01:01:25] because it's not a valid address that's in the page table. So let's actually see, just to double check, what's going on.
[01:01:32] Let's print our buffer again. Our buffer-- well, that's actually kind of interesting, right? So now, buffer, for some reason it
[01:01:38] only says A repeats 128 times. Whereas if you remember before, it said A repeated 180 times
[01:01:45] in our buffer. So what happened? Yeah? AUDIENCE: [INAUDIBLE].
[01:01:51] PROFESSOR: Yeah, yeah. Exactly. So there's actually something going on after the buffer overflow happens that changes what's going on.
[01:01:56] So actually, if you remember, we do this A to i conversion of the string to an integer. And if you provide all As, it actually
[01:02:03] writes zero to this memory location. So a zero, if you remember, terminates strings in C.
[01:02:08] So GDB now thinks, yep, we have a perfectly well-terminated 128 byte string of all As.
[01:02:15] But you know, it doesn't really matter, because we still have those As up top that already corrupted our stack.
[01:02:21] OK. That was actually kind of an important lesson that-- it's actually a little bit tricky, sometimes, to explore these buffer overflows because, even
[01:02:28] though you've already changed lots of stuff on the stack, you still have to get to the point where you use the value that you have somehow
[01:02:34] placed on the stack. So there's other code that's going to run after you've managed to overflow some buffer and corrupt memory.
[01:02:40] You have to make sure that code doesn't do something silly like, if it's A to i, just exited right away,
[01:02:45] as soon as it saw a non-integer value, we might not get to jump to all this 41414141 address.
[01:02:53] So you have to massage your input in some cases. Maybe not so much in this case. But in other situations, you'll have
[01:02:58] to be careful in constructing this input. OK, so just to see what happens, we can jump one more time.
[01:03:04] Well, let's look at our register. So right now, our EIP, the sort of instruction pointer,
[01:03:10] is pointing at the last thing in redirect. And if we step one more time, hopefully we'll jump to, finally, that unfortunate 4141 address.
[01:03:19] Over here. And in fact, yep. The program now seems to be executing there. If we ask GDB to print the current set of registers,
[01:03:25] yep, the current instruction pointer is this strange value. And if we exclude one more instruction,
[01:03:31] it's going to crash because that's finally trying to execute an instruction pointer that doesn't correspond
[01:03:39] to a valid page in the operating system's page table for this process.
[01:03:44] Make sense? Any questions? All right. Well, I've got a question for you guys, actually.
[01:03:52] So what happens-- you know, it seems to be exploitable.
[01:03:58] Or well, OK. Maybe let's first figure out why this is particularly bad, right? So why is it a problem?
[01:04:03] So not only does our program crash, but presumably we're going to take it over. So I guess, first simple question is, OK,
[01:04:09] so what's the problem? What can you do? Yeah? AUDIENCE: You can do whatever you want. PROFESSOR: Yeah. So I was actually pretty silly and just put in lots of As.
[01:04:16] But if you were careful about knowing where to put what values, you might be able to put in a different value
[01:04:21] and get it to jump somewhere else. So let's see if we can actually do this, right? We can retrace this whole thing. OK.
[01:04:27] Re-run the program again. And I guess I have to reset the breakpoint.
[01:04:33] So I can break and redirect again. And run. And this time, I'll, again, next,
[01:04:42] supply lots of As and overflow things. But I'm not going to try to carefully construct--
[01:04:47] you know, figure out which point in these As corresponds to the location in the stack. That's something you guys are going to have to do for lab one.
[01:04:53] But suppose that I overflow the stack here. And then I'm going to manually try to change things on the stack to get it to jump to some point I
[01:05:01] want to jump to. And in this program, OK, so let's again-- nexti.
[01:05:08] Where are we? We're at, again, at the very end of redirect. And let's actually look at the stack, right?
[01:05:14] So if we examine esp here, we see our corrupted pointer. OK. Where could we jump to?
[01:05:21] What interesting things could we do? Unfortunately, this program is pretty limited. There's almost nothing in the program's code
[01:05:26] where you could jump and do anything interesting. But maybe we can do a little bit of something interesting. Maybe we'll find the printf in main
[01:05:33] and jump directly there, and get it to print the x value, or x equals something. So we can do this.
[01:05:38] We can actually disassemble the main function. And main does a bunch of stuff, you
[01:05:44] know, initializes, calls redirect, does some more stuff, and then calls printf. So how about we jump to this point, which is,
[01:05:51] it sets up the argument to printf, which is x equals percent d, and then actually calls printf.
[01:05:58] So we can actually take this value and try to stick it in the stack. And should be able to do this with the debugger
[01:06:05] pretty easily, at least. So you can do this set [? int ?] esp equals this value.
[01:06:11] So we can examine esp again and, indeed, it actually has this value. So if we continue now, well, it printed out x
[01:06:19] equals some garbage, which I guess happens to be just whatever is on the stack that was passed to printf.
[01:06:25] We didn't correctly set up all the arguments because we jumped in the middle of this calling sequence. But yeah, we printed this value.
[01:06:30] And then it crashed. Why did crash? Why do you think?
[01:06:36] What actually happens, right? So we jump to printf. And then, something went wrong.
[01:06:42] Yeah? Well, we changed the return address
[01:06:47] so that when we return from redirect, we now jump to this new address, which is that point up there,
[01:06:52] right after printf. So where's this crash coming from?
[01:06:58] Yeah? AUDIENCE: Is it restricted because your i is supposed to be some sort of integer, but-- PROFESSOR: No, actually, well the i is like,
[01:07:04] well it's a 32-bit register. So whatever's in the register, it'll print. In fact, that's the thing that's in the register. So that's OK.
[01:07:10] Yeah? AUDIENCE: [INAUDIBLE] main returns. PROFESSOR: Yes. Actually, yeah. What's going on is, you have to sort of-- OK,
[01:07:15] so this is the point where we jumped. It's set up some arguments. It actually calls printf. printf seems to work. printf is going to return.
[01:07:22] Now actually, that's fine, because this call instruction put a return address on the stack for printf to use. That's fine.
[01:07:27] Then main is going to continue running. It's going to run the sleeve instruction, which doesn't do anything interesting.
[01:07:32] And then it does another return. But the thing in this-- up to the stack, it doesn't actually have a valid return address.
[01:07:38] So presumably, we return to some other who knows what memory location that's up on the stack and jump somewhere else.
[01:07:44] So unfortunately, here, our pseudoattack didn't really work. It ran some code.
[01:07:49] But then it crashed. That's probably not something you want to do. So if you really wanted to be careful, you would carefully plant not just this return address up
[01:07:56] on the stack, but maybe you'd figure out, where is this second red going to get its return address from,
[01:08:02] and try to carefully place something else on the stack there that will ensure that your program cleanly exits after it gets exploited
[01:08:08] so that no one notices. So this is all stuff you'll sort of try to do in lab one in a little bit more detail.
[01:08:15] But I guess one thing we can try to think about now is, we sort of understand why it's bad to jump to the--
[01:08:24] or to have these buffer overflows.
[01:08:31] One problem, or one sort of way to think of this is that, the problem is just because the return address is up there, right? So the buffer keeps growing and eventually runs
[01:08:38] over the return address. What if we flip the stack around? You know, some machines actually have stacks that grow up.
[01:08:47] So an alternative design we could sort of imagine is one where the stack starts at the bottom
[01:08:55] and keeps going up instead of going down. So then, if you overflow this buffer,
[01:09:01] you'll just keep going up on the stack, and maybe there's nothing bad that will happen.
[01:09:06] Yeah? AUDIENCE: [INAUDIBLE]. PROFESSOR: So you're right.
[01:09:11] It might be that, if you have-- well, so let me draw this new stack diagram. And we'll sort of try to figure out what it applies to and not.
[01:09:20] But OK. So we'll basically just invert the picture. So when you call redirect on this alternative architecture,
[01:09:25] what's going to happen is the return address is going to go here on the stack.
[01:09:31] Then we'll have our i variable, or maybe the saved EBP.
[01:09:36] Then we'll have our i variable. And then we'll have buff. So we'll have buff of zero, buff 127, and so on, right?
[01:09:44] So then when we do the overflow, it overflows up there and maybe doesn't hit anything bad. I guess what you're saying is that,
[01:09:50] well, maybe we had a buffer down there. And if we had a buffer down there, then yeah, that seems kind of unfortunate. It could overrun this return address.
[01:09:58] So you're right. So you could still run into problems on this stack growing up. But what about this exact program?
[01:10:04] Is this particular program safe on machines
[01:10:11] where the stack grows up? So just to recap what the program read is this guy.
[01:10:18] Yeah? AUDIENCE: Still going to overwrite [INAUDIBLE] as a return value. PROFESSOR: Yeah. So that's actually clever, right? So this is the stack frame for redirect.
[01:10:29] I guess it actually spans all the way up here. But what actually happens when you call getS() is that
[01:10:34] redirect makes a function call. It actually saves its return address up here on the stack.
[01:10:40] And then getS() starts running. And getS() puts its own saved EBP up here.
[01:10:45] And getS() is going to post its own variables higher up. And then getS() is going to fill in the buffer.
[01:10:54] So this is still problematic. Basically, the buffer is surrounded by return initials on all sides.
[01:10:59] Either way, you're going to be able to overflow something. So at what point-- suppose we had a stack growing up machine.
[01:11:06] At what point would you be able to take control of the program's execution then?
[01:11:14] Yes, and that is actually even easier in some ways. You don't have to wait until redirect returns. And maybe there was like, stuff that was going to mess you up
[01:11:20] like this A to i. No. It's actually easier, because getS() is going to overflow the buffer. It's going to change the return address
[01:11:26] and then immediately return and immediately jump to wherever you sort of tried to construct,
[01:11:32] makes sense. So what happens if we have a program like this
[01:11:38] that's pretty boring? There's like no real interesting code to jump to. All you can do is get it to print different x values here.
[01:11:45] What if you want to do something interesting that you didn't-- yeah? AUDIENCE: I mean, if you have an extra cable stack,
[01:11:52] you could put arbitrary code that, for example, executes a shell? PROFESSOR: Yeah yeah yeah.
[01:11:57] So that's kind of clever, right, because you actually can supply other inputs, right? So at least, well-- there's some defenses against this.
[01:12:04] And we'll go over these in subsequent lectures. But in principle, you could have the return address here
[01:12:10] that you override on either the stack up or stack down machine. And instead of pointing it to some existing code,
[01:12:16] like the printf inside of main, we can actually have the return address point into the buffer.
[01:12:22] So it's previously just some location on the stack. But you could jump there and treat it as executable. So as part of your request, you'll actually
[01:12:29] send some bytes of data to the server, and then have the return address or the thing you overwrite here
[01:12:35] point to the base of the buffer, and you'll just keep going from there. So then you'll be able to sort of provide
[01:12:41] the code you want to run, jump to it, and get the server to run it. And in fact, traditionally, in Unix systems,
[01:12:46] what adversaries would often do is just ask the operating system to execute the binsh command, which lets you sort of type in arbitrary shell commands
[01:12:53] after that. So as a result, this thing, this piece of code you inject into this buffer, was often called, sort of for historical reasons, shell code.
[01:13:01] And you'll try to construct some in this lab one as well.
[01:13:06] All right. Make sense, what you can do here? Any questions? Yeah? AUDIENCE: Is there a separation between code and data?
[01:13:13] PROFESSOR: Right. So is there a separation between code and data here? At least, well, historically, many machines
[01:13:20] didn't enforce any separation of code and data. You'd just have a flat memory address space. The stack pointer points somewhere.
[01:13:26] The code pointer points somewhere else. And you just execute wherever the code pointer, instruction pointer is pointing.
[01:13:32] Modern machines try to provide some defenses for these kinds of attacks. And what modern machines often do is,
[01:13:39] they actually associate permissions with various memory regions. And one of the permissions is execute.
[01:13:44] So the part of your 32-bit or 64-bit address space that contains code has the execute permission.
[01:13:51] So if your instruction pointer points there, the CPU will actually run those things. And the stack and other data portions of your address space
[01:13:59] typically don't have the execute permission. So if you happen to somehow set your instruction pointer to some non-code memory location, you can set it,
[01:14:07] but the CPU will refuse to execute it. So this is a reasonably nice way to defend
[01:14:13] against these kinds of attacks. But it doesn't prevent quite everything. So just a question.
[01:14:19] OK. So how would you bypass this if you had this non-executable stack? You actually saw this example earlier, right,
[01:14:26] when I actually jumped to the middle of main. So that was a way of sort of exploiting this buffer
[01:14:34] overflow without having to inject new code of my own. So even if the stack was non-executable,
[01:14:39] I would still be able to jump in the middle of main. In this particular case, it's kind of boring. It just prints x and crashes.
[01:14:45] But in other situations, you might have other pieces of code in your program that are doing interesting stuff that you really
[01:14:50] do want to execute. And that's sort of called return to libc attacks for, again, somewhat historical reasons.
[01:14:56] But it is a way to bypass the security measures. So in the context of buffer overflows,
[01:15:02] there's not really a clear cut solution that provides perfect protection against these mistakes
[01:15:08] because, at the end of the day, the programmer did make some mistake in writing this source code. And the best way to fix it is probably just to change
[01:15:14] the source code and make sure you don't call getS() very much, like the compiler warned you. And there's more subtle things that the compiler
[01:15:20] doesn't warn you about. And you still have to avoid making those calls. But because it's hard, in practice,
[01:15:26] to change all the software out there, many people try to devise techniques that make it more difficult to exploit these bugs.
[01:15:33] For example, making the stack non-executable, so you can't inject the shell code onto the stack,
[01:15:39] and you have to do something slightly more elaborate. And next couple of lectures, next two lectures,
[01:15:45] actually, we'll look at these defense techniques. They're not all perfect. But they do, in practice, make it much more difficult for that hacker to exploit things.
[01:15:52] Question? AUDIENCE: I just have a general administrative question. PROFESSOR: Yeah? AUDIENCE: I was wondering if there was a final? And also if there are quizzes, and what dates--
[01:15:58] PROFESSOR: Oh yeah. Yeah, I think if you go to the schedule page, there's two quizzes.
[01:16:03] And there's no final during the final week, but there's a quiz right before it. So you're free for the final week,
[01:16:09] but there's still something at the end of the class. Yeah. All right.
[01:16:14] OK. So I think that's probably it for buffer overflows. I guess the one question is, so what
[01:16:19] do you do about mechanism problems? And the general answer is to probably have fewer mechanisms.
[01:16:26] So as we saw here, if you're relying on every piece of software to enforce your security policy, you'll inevitably have mistakes that
[01:16:31] allow an adversary to bypass your mechanism to exploit some bug in the web server. And a much better design, and one but
[01:16:37] you will explore in lab two, is one where you structure your whole system so the security of the system doesn't
[01:16:42] depend on all the pieces of software enforcing your security policy. The security policy is going to be enforced by a small number of components.
[01:16:48] And the rest of the stuff actually doesn't matter, for security purposes, if it's right or wrong. It's not going to violate your security policy at all.
[01:16:55] So this, kind of minimizing your trusted computing base is a pretty powerful technique to get around these mechanism
[01:17:01] bugs and problems that we've looked at today, at least in a little bit of detail. All right. So read the paper for Monday.
[01:17:07] And come to Monday's lecture. And submit the questions on the website. See you guys then.