# Lecture 2 – Control Hijacking Attacks

## 0. Big Picture (00:00:26)

Control hijacking attacks (like buffer overflows) let an attacker **take over where a program executes next**. The attacker:

1. **Corrupts control data** (e.g., a return address, a function pointer).
2. **Redirects execution** to code of their choosing (their own code or existing code used in a new way).

To really understand both the attacks and the defenses, we need three ingredients:

- How C treats memory and pointers.
- How stacks, heaps, and function calls are represented on x86.
- How software and hardware defenses can restrict what pointers can do.

This lecture walks through:

1. A quick review of buffer overflows.
2. Three high-level ways to “fix” them.
3. Two concrete mitigation families:
	- **Stack canaries**.
	- **Bounds checking** (with a focus on **Baggy Bounds Checking**).

Throughout, keep the following **threat model** in mind:

- The attacker can supply inputs to your program (e.g., HTTP requests, command-line arguments).
- The attacker **cannot** directly write arbitrary memory.
- The attacker **can** exploit bugs in your program (especially unsafe memory use in C) to gain that ability.

---

## 1. Review: Buffer Overflows in C (00:00:26)

### 1.1 Why C Programs Are Vulnerable

Many critical systems are written in C:

- Operating systems, file systems.
- Databases, compilers, network servers.
- Shells and system utilities.

Reasons:

- C is “high-level assembly”: small runtime, close to the hardware, good performance.
- C exposes **raw memory addresses** (pointers).
- C **does not do automatic bounds checking** on arrays or pointers.

Hardware also typically does **not** know which pointer values are “in bounds” for which objects. The default contract is: if a pointer is in your process’s virtual address space, the hardware assumes the access is fine.

This combination–raw pointers, no bounds, and performance pressure–means **a single bug in pointer or array handling can corrupt arbitrary memory**.

### 1.2 Classic Stack Buffer Overflow

Consider this code:

```c
void read_req() {
	 char buf[128];
	 int i;
	 gets(buf);    // DANGEROUS: no bounds checking
	 // ... use buf ...
}
```

On x86, a typical stack frame looks like:

```text
	Higher addresses
	+------------------+  <--- saved state for caller and earlier frames
	|  ...             |
	+------------------+
	|  return address  |
	+------------------+
	|  saved %ebp      |
	+------------------+
	|  buf[127]        |
	|   ...            |
	|  buf[0]          |
	+------------------+
	|  i               |
	+------------------+  <--- current %esp
	Lower addresses     (stack grows “downward”)
```

Key details:

- `gets(buf)` keeps reading characters until a newline or EOF, **without knowing or checking** the size of `buf`.
- If the user inputs more than 128 bytes, the extra bytes **overflow past `buf` on the stack**.
- Those extra bytes can overwrite:
  - Local variables (`i`),
  - The saved base pointer (`%ebp`),
  - **The return address**.

### 1.3 What the Attacker Gains

If the attacker can overwrite the **return address**, they control where execution continues when `read_req` returns.

Typical plan:

1. Place **attacker-chosen bytes** in the overflowing input (this can include machine code, or data used by later gadgets).
2. Arrange the overflow so that bytes at the **return address slot** form an address the CPU will later jump to.
3. When the function returns, the CPU pops the **corrupted return address** and jumps wherever the attacker specified.

If the vulnerable program is privileged (e.g., running as root or inside a trusted network segment), the attacker’s code now executes with those **same privileges**:

- Read or modify sensitive files.
- Send spam or exfiltrate data.
- Pivot inside a firewall (once you control a machine inside, other internal machines may trust you implicitly).

### 1.4 Why the OS Usually Doesn’t Notice

Intuition: “Isn’t the OS supposed to protect us from this?”

- The OS enforces **process isolation** using page tables.
- But all of the memory being accessed (buffer, return address, locals) belongs to **this same process**.
- To a first approximation, the OS:
  - Sets up page tables and some protections.
  - Then lets the user process run until it performs I/O or a system call.

The overflow is **“within the rules”** of the current process’s address space:

- No page protections are violated.
- No kernel or other process memory is touched.

So the hardware and OS see nothing illegal. The bug is in **our C code**, and the hardware faithfully executes it.

Later in the lecture, we’ll exploit **hardware mechanisms** (like page protections and address layout) to help defend against overflows.

---

## 2. High-Level Ways to Fix Buffer Overflows (00:09:39)

There are three broad strategies, each with strengths and weaknesses.

### 2.1 Strategy 1 – Avoid Bugs in C Code

Goal: Write C code that is actually **memory-safe**.

Practices:

- Use **safe library functions**:
  - `fgets` instead of `gets`.
  - `strncpy`, `snprintf` instead of `strcpy`, `sprintf`.
- Treat **compiler warnings as errors**:
  - Uninitialized variables.
  - Suspicious casts.
  - Use of unsafe functions.
- Carefully track buffer sizes and invariants in your own parsing and serialization code (not just wrappers around libc calls).

Problems:

- On large C codebases, it’s extremely hard to be sure you have **no bugs**.
- Pointer-heavy, weakly-typed code can be hard even to understand, let alone formally verify.

Still, this is the only strategy that is truly **“correct by construction”** if you can pull it off.

### 2.2 Strategy 2 – Tools that Find Bugs

Here, we accept that humans are fallible and rely on tools to catch many (not all) memory errors.

**Static analysis**:

- Analyze source code **without running it**.
- Example:

  ```c
  void foo(int *p) {
		int offset;
		int *z = p + offset;   // offset is uninitialized
		if (offset > 7) {
			 bar(offset);
		}
  }
  ```

  - A static analyzer can infer that `offset` is used before it’s initialized.
  - It can also infer constraints: e.g., in `bar`, `offset > 7` holds along this path.

**Fuzzing**:

- Automatically generate many random or structured inputs to exercise your code.
- Aim: **high code coverage**, especially of rare branches and corner cases.
- Often combined with light-weight instrumentation to steer inputs toward untested paths.

Pros:

- Can catch many bugs **before deployment**.
- Even incomplete tools are valuable: fewer bugs than before is a win.

Cons:

- Hard to prove the **absence** of bugs.
- C’s flexibility makes “complete” static checking very hard.

### 2.3 Strategy 3 – Use a Memory-Safe Language

Examples: **JavaScript, Java, C#, Python**, many others.

Properties:

- No raw pointer arithmetic in user code.
- Array and string accesses are **bounds checked**.
- Memory is managed by a **garbage collector** rather than manual `malloc`/`free`.

Benefits:

- Vastly reduces entire classes of memory corruption bugs.
- Many attacks that rely on control over raw addresses simply don’t work.

Challenges:

- **Legacy code**: enormous existing C/C++/Fortran/COBOL code bases.
- **Low-level access**: device drivers, kernels, and runtimes still need to talk to hardware directly.
- **Performance concerns**:
  - Historically: interpreted high-level languages were much slower than C.
  - Today: JIT compilation and advanced VMs narrow the gap (often within a small constant factor of C).
  - Many real workloads are **I/O-bound** rather than CPU-bound; raw CPU speed may not matter as much as people fear.

Key point: even in a “safe” language, the underlying runtime (written in C/C++) must itself be secure. Attacks like **heap spraying** target that layer.

---

## 3. What Exactly Does a Buffer Overflow Exploit? (00:24:59)

Two main ingredients:

1. **Gain control over a code pointer**
	- Return address on the stack.
	- Function pointers (on stack, heap, or global data).
	- C++ vtable pointers.
	- Exception handler addresses, etc.

2. **Make that pointer target malicious behavior**
	- Inject new code (classic “shellcode in the buffer” attacks).
	- Or re-use existing code in a new order (e.g., return-oriented programming, which we will see later).

The tricky constraint for the attacker is usually **knowing where in memory** to point that corrupted pointer:

- Where is the buffer located this run?
- Where do dynamically loaded libraries land?
- Where are particular functions or gadgets?

Defenses can try to **randomize or restrict these locations** so the attacker can’t easily guess the right address.

---

## 4. Mitigation 1 – Stack Canaries (00:27:27)

### 4.1 Intuition

Goal: Detect (and stop) stack-based buffer overflows **before** we use a corrupted return address.

Idea:

1. On function entry, the compiler inserts a **canary value** on the stack between local buffers and the saved return address.
2. On function return, the compiler-generated epilogue **checks that the canary is unchanged**.
3. If the canary is corrupted, the program aborts instead of jumping to the attacker’s address.

Stack frame with canary:

```text
	Higher addresses
	+------------------+  <--- previous frame
	|  ...             |
	+------------------+
	|  return address  |
	+------------------+
	|  saved %ebp      |
	+------------------+
	|  CANARY VALUE    |  <-- inserted by compiler
	+------------------+
	|  buf[127]        |
	|   ...            |
	|  buf[0]          |
	+------------------+
	Lower addresses (overflow grows “upward” toward canary and return address)
```

Any simple contiguous overflow that reaches the return address **must** first overwrite the canary.

### 4.2 Choosing Canary Values

**Bad choice:** a fixed, predictable constant (e.g., `0x41414141`).

- Attacker learns the constant.
- Overwrites the buffer with the correct canary in the right position.
- Check passes; exploit succeeds.

Two better styles:

1. **Terminator canary**
	- Canary bytes chosen from characters that many C string routines treat as **terminators**:
	  - `\0` (null byte),
	  - `\r`, `\n` (carriage return, newline),
	  - `-1` (often used as sentinel).
	- For many unsafe functions (`gets`, `strcpy`, etc.), reaching these bytes **stops copying**, preventing the overflow from crossing the canary.

2. **Random canary**
	- A random value generated once per process, stored in a place the attacker cannot read.
	- Makes guessing the canary difficult.
	- Effectiveness depends on how many **bits of true randomness** the system provides.

Warning: poor randomness (weak PRNGs, predictable seeds like current time) has broken many defenses in practice.

### 4.3 When Canaries Fail

Canaries defend only **one specific path of attack**: overflowing a local buffer into the function’s **own** saved control data.

They do **not** protect against:

1. **Overwriting function pointers or data pointers elsewhere**

	Example:

	```c
	int *ptr = ...;   // some pointer
	char buf[128];
	gets(buf);        // overflows into ptr
	*ptr = 5;         // writes 5 to attacker-chosen address
	```

	- Here, the overflow never touches the return address.
	- The attacker just corrupts `ptr` and later uses it to write to an arbitrary location.
	- The canary is never consulted.

2. **Heap metadata corruption (malloc/free attacks)**

	Rough sketch of the pattern:

	```c
	char *p = malloc(1024);
	char *q = malloc(1024);

	strcpy(p, attacker_input);  // may overflow into q’s metadata

	free(q);   // operates on corrupted metadata
	free(p);
	```

	- Many heap allocators maintain **metadata structures** around each block:
	  - Size fields.
	  - Doubly-linked list pointers (`bkwd`, `fwd`) for free lists.
	- If the attacker overwrites the **size** field for `q`’s block, later `free` calls may treat attacker data as a struct and execute pointer assignments like:

	  ```c
	  fwd->bk = bck;
	  bck->fd = fwd;
	  ```

	- Carefully chosen fake metadata lets the attacker perform **arbitrary writes** (e.g., overwrite a return address elsewhere in memory).
	- Stack canaries on function frames do nothing to stop this.

3. **Guessable or leaked random canaries**

	- If the random canary has too few entropy bits (few real possibilities), brute-force becomes feasible.
	- If the attacker can read memory (another bug), they may directly observe the canary.

Conclusion: **Canaries are useful but narrow**. They harden a classic exploit pattern but leave many other memory corruption channels open.

---

## 5. Mitigation 2 – Bounds Checking (00:51:22)

Instead of trying only to catch specific overwrite patterns (like stack canaries), we can try to **enforce that pointers stay within the bounds of objects**.

### 5.1 Ideal vs. Practical Goals

In a perfect world, we would like to enforce **“totally correct” pointer semantics**:

- Every pointer always refers to the **intended** object.
- All uses of that pointer respect the programmer’s intended invariants.

In C, that’s essentially impossible to reconstruct automatically because:

- Pointers carry **no type/ownership metadata at runtime**.
- The same bytes may be interpreted via:
  - Different pointer types.
  - Unions.
  - Explicit casts.

Example:

```c
char x[1024];
char *y = &x[107];
```

- If `x` is being used as a string buffer, incrementing `y` may be reasonable.
- If `x` encodes a network packet with an internal structure, `&x[107]` might land in the middle of some header field and be semantically meaningless.

Unions make it even trickier:

```c
union u {
	 int i;
	 struct { int j; int k; } s;
};

int *ptr = &u.s.k;  // Is this “valid” right now?
```

- At any moment, logically **only one** union arm is “active”.
- But at the raw memory level, all interpretations overlap.

Because of this, many systems settle for a **weaker but still useful goal**:

> For a pointer `p'` derived from base pointer `p`, all dereferences of `p'` must stay within the **allocated object** that originally belonged to `p`.

This does *not* guarantee semantic correctness (you can still mangle your own data), but it prevents **arbitrary cross-object overwrites**.

### 5.2 Two Operations to Interpose On

To track whether derived pointers are still within bounds, we must instrument two kinds of operations:

1. **Pointer arithmetic**
	- Example: `char *q = p + i;`
	- This is where we propagate “where is this pointer relative to its base?”

2. **Pointer dereferences**
	- Example: `char ch = *q;`
	- This is where we decide “is this use of `q` allowed?”

You need both:

- Only instrumenting dereferences: you don’t know where `q` came from or what its bounds should be.
- Only instrumenting arithmetic: many C programs temporarily construct out-of-bounds pointers (e.g., `end + 1` as a sentinel) but **never dereference them**; immediately crashing there would break valid code.

### 5.3 Bounds Checking Approaches

#### 5.3.1 Electric Fences

Idea:

- For each heap allocation, place a **guard page** immediately after (or around) it.
- Mark that guard page as **inaccessible** using the hardware page tables.
- Any attempt to read/write past the allocation hits the guard page and causes a fault.

Pros:

- Simple to implement in `malloc`/`free`.
- Does **not** require recompiling the application.
- Excellent as a **debugging tool**: overflows cause immediate crashes instead of latent corruption.

Cons:

- Huge memory overhead: one or more whole pages (e.g. 4 KiB) per object.
- Typically only used for **testing**, not in production.
- Main focus is heap objects; does not (by itself) protect stack frames.

#### 5.3.2 Fat Pointers

Idea:

- Change what a pointer **is**: instead of just an address, store both the address **and its bounds**.

Example representation (32-bit machine):

```text
Regular pointer (32 bits)
  [ address ]

Fat pointer (96 bits)
  [ base ][ end ][ current ]
```

For each use:

- The compiler inserts checks that `current` lies in `[base, end)`.
- On pointer arithmetic, only `current` changes; `base` and `end` stay the same.

Example:

```c
int *ptr = malloc(2 * sizeof(int));
while (1) {
	 *ptr = 42;   // checked against base/end
	 ptr++;       // advances ‘current’
}
```

- First two `*ptr` stores are allowed.
- On the third iteration, `current` moves outside `[base, end)`; check fails and the program aborts.

Drawbacks:

- **Incompatibility** with existing binaries and ABIs:
  - Libraries compiled for regular pointers can’t handle fat pointers.
  - `sizeof(struct)` changes if pointers inside it grow.
- **Atomicity issues**:
  - Updating a fat pointer may require multiple word-sized writes.
  - Code that assumes pointer writes are atomic can break.

Despite these problems, fat pointers are a clean conceptual model; Baggy Bounds takes a different route to preserve compatibility.

---

## 6. Baggy Bounds Checking – Overview (01:16:26)

Baggy Bounds Checking is a **practical bounds checking scheme** that tries to be:

- **Efficient**: constant-time operations; small overhead.
- **Backwards-compatible**: ordinary pointer sizes; works well with existing C code.

Key ideas:

1. Round each allocation up to a **power of 2** and **align** it to that size.
2. Represent each object’s bound by the **log₂ of its size**.
3. Maintain a global **bounds table** (a linear array) indexed by chunks of the address space.
4. Use an **OOB (out-of-bounds) bit** in pointers and the VM system to catch illegal dereferences.

We’ll first recall a related allocation technique—**buddy allocation**—then see how Baggy Bounds uses similar structure.

---

## 7. Buddy Allocation Refresher (01:11:37)

Buddy allocation is a classic memory management algorithm that:

- Treats free memory as blocks whose sizes are powers of 2.
- Splits and merges blocks to satisfy allocation and deallocation requests.

Simplified example (total heap size: 128 bytes):

1. Entire heap is one block: size 128.
2. Request: `malloc(28)`.
	- 128 is too big.
	- Split into two 64-byte blocks.
	- 64 is still too big; split into two 32-byte blocks.
	- 28 bytes **fits in 32**, and is at least half of 32, so allocate one 32-byte block.
3. Later request: `malloc(50)`.
	- Use the remaining 64-byte block (50 fits and is at least half of 64).
4. When freeing blocks, if two **adjacent** blocks of the same size are free, merge them into a larger block (their “buddy”).

Why we care:

- The power-of-two structure makes arithmetic on blocks and indexes **simple and fast**.
- Baggy Bounds adopts a similar power-of-two alignment to keep bounds information compact and easy to compute.

---

## 8. Baggy Bounds in Detail (01:16:26)

### 8.1 Five Main Tricks

Baggy Bounds applies five key tricks:

1. **Round up and align allocations**
	- Every allocation size is rounded up to a power of 2 (e.g., 16, 32, 64, … bytes).
	- The allocation is aligned to that power-of-two boundary.

2. **Store bounds as log₂(size)**
	- Instead of storing full sizes (e.g., 64), store `log₂(64) = 6`.
	- For 32-bit pointers, the largest practical object sizes need at most a few bits of exponent.

3. **Use a linear bounds table at slot granularity**
	- Memory is conceptually divided into **slots** (e.g., 16-byte chunks).
	- A global bounds table stores **one byte per slot**, containing the log₂(size) exponent for the allocation that covers that slot.

	Example (slot size = 16):

	- `p = malloc(16);`
	  - Rounded size: 16 (2⁴); log₂ size = 4.
	  - Bounds table entry for `p / 16` is set to 4.

	- `p = malloc(32);`
	  - Rounded size: 32 (2⁵); log₂ size = 5.
	  - Allocation spans 2 slots (32 / 16 = 2).
	  - Both table entries (`p / 16` and `p / 16 + 1`) are set to 5.

4. **Use efficient arithmetic to recover base and size**

	Given a known-good pointer `p`, Baggy Bounds computes:

	```c
	size = 1 << table[p >> log_of_slot_size];
	base = p & ~(size - 1);
	```

	- `p >> log_of_slot_size` indexes the bounds table (dividing by slot size).
	- `table[...]` returns the exponent; `1 << exponent` reconstructs the object’s size.
	- `base` is computed by **masking off** the low bits of `p` to align it to the object boundary.

	Then, for derived pointer `p' = p + i`, check:

	```c
	(p' >= base) && ((p' - base) < size)
	```

	If this test fails, `p'` is out of bounds.

	The paper also presents an equivalent **optimized bounds check** using bitwise operations:

	```c
	(p ^ p') >> table[p >> log_of_slot_size] == 0
	```

	This avoids some arithmetic but encodes the same idea.

5. **Exploit virtual memory for cheap OOB enforcement**

	- For pointers that are “just slightly” out of bounds (within half a slot), Baggy Bounds **sets a high-order bit** to mark them as OOB.
	- The OS arranges that all addresses with that bit set map into an **inaccessible region** of the virtual address space.
	- Thus, if such a pointer is dereferenced, the hardware raises a fault **without needing an explicit software check at every dereference**.

	The result: most pointer dereferences proceed at near “normal C” speed, while out-of-bounds dereferences reliably fault.

### 8.2 Example Walkthrough

Assume:

- Slot size = 16 bytes.
- Baggy Bounds is interposed on allocations and pointer arithmetic.

Code:

```c
char *p = malloc(44);
char *q = p + 60;
char *r = q + 16;
char *s = q + 8;
char *t = s - 32;
```

1. `p = malloc(44);`
	- Rounded size = 64 bytes (next power of 2).
	- Number of slots = 64 / 16 = 4.
	- Bounds table entries for those 4 slots store `log₂(64) = 6`.

2. `q = p + 60;`
	- 60 is **past the logical object size** (44), but still within its baggy bound (64).
	- `q` is technically out-of-bounds for the **logical** object but inside the **baggy** region.

3. `r = q + 16;` (offset 76 from `p`)
	- 76 > 64; this is more than half a slot beyond the baggy bound.
	- Baggy Bounds treats this as a **hard error**; further use of `r` will fault.

4. `s = q + 8;` (offset 68 from `p`)
	- Only 4 bytes beyond the 64-byte baggy region.
	- This is **within half a slot**, so Baggy Bounds does **not** immediately crash.
	- Instead, it sets an **OOB bit** in `s` to mark it dangerous.

5. `t = s - 32;`
	- Moves back inside the legal 64-byte region.
	- OOB bit can be cleared; `t` is safe again.

Intuition:

- Small “straddling” out-of-bounds pointers (very common in C idioms) are tolerated but tracked.
- Large out-of-bounds steps quickly lead to **faults**, preventing the pointer from wandering arbitrarily across memory.

### 8.3 What Baggy Bounds Achieves

Strengths:

- Prevents many classic **heap and stack overflow**-style writes from stepping into unrelated objects.
- Makes it much harder to corrupt **distant control data** (e.g., vtables, unrelated function pointers) via a single out-of-bounds pointer.
- Uses only a compact global bounds table and pointer tagging; does not require changing pointer sizes.

Limitations:

- Like other bounds-checking schemes, it enforces a **weaker property** than full semantic correctness.
- Programs can still corrupt their **own** objects in semantically wrong ways.
- Requires compiler and runtime support; uninstrumented code won’t be protected.

Still, in the world of C, “you can only stomp on your own allocations” is a big improvement over “you can stomp on anything in the process.”

---

## 9. Key Takeaways & Memory Aids

### 9.1 Mental Model Checklist

When you see a C program manipulating buffers and pointers, ask:

1. **Where is this buffer stored?**
	- Stack? Heap? Global data?
2. **What control data is nearby in memory?**
	- Return addresses, function pointers, malloc metadata, vtables.
3. **What happens on malformed or oversized input?**
	- Does any copy/parse ignore buffer size?
4. **Which defenses are in play?**
	- Compiler options: stack canaries, bounds-checking instrumentation.
	- Runtime: electric-fence style allocators, Baggy Bounds or ASan.

### 9.2 Short Mnemonics

- **“C is high-level assembly”** → expect raw pointers, weak guarantees.
- **“Two steps to hijack”** → control a code pointer, then point it at evil.
- **“Canaries catch classic stack smashes”** → good for overflows into return addresses, but not for all memory bugs.
- **“Bounds, not meaning”** → bounds checking enforces where pointers can go, not what they’re *supposed* to mean.
- **“Baggy = powers of two + table”** → allocations rounded to powers of two, logged in a table indexed by slots.

If you remember those five phrases, you will retain the essential structure of this lecture and be able to reconstruct the technical details when you need them.

---

## 10. What Comes Next (summary, no direct timestamp)

In later lectures, we build on these foundations to study:

- Code reuse attacks (e.g., return-oriented programming) that work even when **code injection** is blocked.
- Additional mitigations: non-executable stacks, address space layout randomization (ASLR), and more.
- How these ideas interact with real-world systems and performance constraints.

But all of those defenses rest on understanding today’s topic: **how C and x86 let control hijacking happen, and how mechanisms like canaries and Baggy Bounds can partially contain the damage.**

